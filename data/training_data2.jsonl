{"prompt": "Explain the functionality of the AdvancedFormNode component.", "completion": "Explanation:\nThe AdvancedFormNode is a react component which can render a combination of antd form, antd form list, table. The component receives a json schema and based on its content we the code decide to show antd form or antd form list or antd table or a combination of any two or any one of the following. If the json schema contains a key topOptions this means that the antd form will be rendered because the topOptions will be an array of objects and each object will contain schema for one form field. Similarly if listOptions is present this means antd form list will be rendered. listOptions will be array of object where each object will contain schema for one antd form list field. Similarly for table to be rendered the schema will contain defaultColumns and tableData keys. Both defaultColumns and tableData are array of objects, tableData will contain the data for each row while defaultColumn contains the schema for each column of the table.  The schema will also contains dependency will updates the advancedformnode component as per the requirements. Depenedencies are of multiple types like topOptionDependency, listOptionDependency, enableListOptionDependency, validation, onLoadDependency, transformation, tableRowTransformation, each dependency has its own requirement. topOptionDependency is used to update the topOptions key from the input schema and the changes are reflected in form, similarly listOptionDependency is used to update listOptions key in the input schema based on certain user input, enableListOptionDependency is used in a way to enable the rendering of form list, here user make some changes in form fields and according to that if the enableListOptionDependency condition is satisfied listOptions are rendered, validation dependency is used to apply validation on the form fields, form list fields and table elements and so on.\n<|endoftext|>"}
{"prompt": "Provide the details and example schema for rendering an AdvancedFormNode table.", "completion": "Explanation: \nAdvancedFormNode schema which contains only table looks like this: Each column can have a type of either text, number or select. if the type of the field is select than there will be options or options_query to get the select options. Each column can be either editable or not based on the value of the editable key. width of every column is determined by the value of the width key.\n\n Schema:\n{\"defaultColumns\":[{\"key\":\"patient_name\",\"type\":\"text\",\"title\":\"Patient Name\",\"width\":100,\"dataIndex\":\"patient_name\",\"fixed\":\"left\"},{\"key\":\"responsible_party\",\"type\":\"text\",\"title\":\"Responsible Party\",\"width\":100,\"dataIndex\":\"responsible_party\",\"fixed\":\"left\"},{\"key\":\"service_date\",\"type\":\"text\",\"title\":\"Service Date\",\"width\":100,\"dataIndex\":\"service_date\",\"fixed\":\"left\"},{\"key\":\"procedure_code\",\"type\":\"text\",\"title\":\"Procedure Code\",\"width\":100,\"dataIndex\":\"procedure_code\",\"fixed\":\"left\"},{\"key\":\"service_provider\",\"type\":\"text\",\"title\":\"Service Provider\",\"width\":200,\"dataIndex\":\"service_provider\"},{\"key\":\"charges\",\"type\":\"text\",\"title\":\"Charges\",\"width\":150,\"dataIndex\":\"charges\"},{\"key\":\"balance\",\"type\":\"number\",\"title\":\"Balance\",\"width\":150,\"dataIndex\":\"balance\"},{\"key\":\"allowed\",\"type\":\"number\",\"title\":\"Allowed\",\"width\":150,\"editable\":true,\"dataIndex\":\"allowed\"},{\"key\":\"payments\",\"type\":\"number\",\"title\":\"Payments\",\"width\":150,\"editable\":true,\"dataIndex\":\"payments\",\"verticalSum\":false},{\"key\":\"not_allowed\",\"type\":\"number\",\"title\":\"Not Allowed\",\"width\":150,\"editable\":true,\"dataIndex\":\"not_allowed\"},{\"key\":\"interest_payment\",\"type\":\"number\",\"title\":\"Interest Payment\",\"width\":150,\"editable\":true,\"dataIndex\":\"interest_payment\"},{\"key\":\"co_pay\",\"type\":\"number\",\"title\":\"Co-Pay\",\"width\":150,\"editable\":true,\"dataIndex\":\"co_pay\"},{\"key\":\"co_ins\",\"type\":\"number\",\"title\":\"Co-Ins\",\"width\":150,\"editable\":true,\"dataIndex\":\"co_ins\"},{\"key\":\"deductible\",\"type\":\"number\",\"title\":\"Deductible\",\"width\":150,\"editable\":true,\"dataIndex\":\"deductible\"},{\"key\":\"transfer_to\",\"type\":\"select\",\"title\":\"Transfer To\",\"width\":250,\"editable\":true,\"dataIndex\":\"transfer_to\",\"options_query\":\"query|select 'patient'||'|'||d.id as id, d.first_name||' '||d.last_name as name from encounter e inner join demographics d ON d.id = cast(e.demographics_id as integer) where e.id ='%(encounter_id)s' union select 'insurance'||'|'||i.id as id, i.name as name from encounter e inner join insurance_info i ON e.demographics_id=i.patient_id left join demographics d ON d.id = cast(e.demographics_id as integer) where e.id ='%(encounter_id)s' and i.status='active'\"},{\"key\":\"notes\",\"type\":\"text\",\"title\":\"Notes\",\"width\":350,\"editable\":true,\"dataIndex\":\"notes\"},{\"key\":\"additional_adjustment_1\",\"type\":\"number\",\"title\":\"Additional Adj. 1\",\"width\":150,\"editable\":true,\"dataIndex\":\"additional_adjustment_1\"},{\"key\":\"additional_reason_type_1\",\"type\":\"select\",\"title\":\"Reason Type 1\",\"width\":150,\"options\":[{\"value\":\"CO\",\"display_value\":\"CO\"},{\"value\":\"OA\",\"display_value\":\"OA\"},{\"value\":\"PI\",\"display_value\":\"PI\"}],\"editable\":true,\"dataIndex\":\"additional_reason_type_1\"},{\"key\":\"additional_adjustment_2\",\"type\":\"number\",\"title\":\"Additional Adj. 2\",\"width\":150,\"editable\":true,\"dataIndex\":\"additional_adjustment_2\"},{\"key\":\"additional_reason_type_2\",\"type\":\"select\",\"title\":\"Reason Type 1\",\"width\":150,\"options\":[{\"value\":\"CO\",\"display_value\":\"CO\"},{\"value\":\"OA\",\"display_value\":\"OA\"},{\"value\":\"PI\",\"display_value\":\"PI\"}],\"editable\":true,\"dataIndex\":\"additional_reason_type_2\"},{\"key\":\"remark_codes\",\"type\":\"text\",\"title\":\"Remark Codes\",\"width\":150,\"editable\":true,\"dataIndex\":\"remark_codes\"}],\"tableData\":[{\"key\":1,\"patient_name\":\"John Doe\",\"responsible_party\":\"Jane Doe\",\"service_date\":\"2024-02-25\",\"procedure_code\":\"12345\",\"service_provider\":\"Hospital ABC\",\"charges\":null,\"balance\":\"250\",\"allowed\":null,\"payments\":null,\"not_allowed\":null,\"interest_payment\":null,\"co_pay\":null,\"co_ins\":null,\"deductible\":null,\"transfer_to\":\"Another Department\",\"notes\":\"Patient requested detailed invoice\",\"additional_adjustments_1\":0,\"additional_reason_type_1\":\"CO\",\"additional_adjustments_2\":0,\"additional_reason_type_2\":\"CO\",\"remark_codes\":\"PR\"},{\"key\":2,\"patient_name\":\"Alice Smith\",\"responsible_party\":\"Bob Smith\",\"service_date\":\"2024-02-26\",\"procedure_code\":\"54321\",\"service_provider\":\"Clinic XYZ\",\"charges\":\"300\",\"balance\":\"175\",\"allowed\":null,\"payments\":null,\"not_allowed\":null,\"interest_payment\":null,\"co_pay\":null,\"co_ins\":null,\"deductible\":null,\"transfer_to\":\"Accounting Department\",\"notes\":\"Insurance company confirmed payment\",\"additional_adjustments_1\":0,\"additional_reason_type_1\":\"CO\",\"additional_adjustments_2\":0,\"additional_reason_type_2\":\"CO\",\"remark_codes\":\"CO\"},{\"key\":3,\"patient_name\":\"Emily Johnson\",\"responsible_party\":\"David Johnson\",\"service_date\":\"2024-02-24\",\"procedure_code\":\"98765\",\"service_provider\":\"Surgery Center\",\"charges\":\"1000\",\"balance\":\"500\",\"allowed\":null,\"payments\":null,\"not_allowed\":null,\"interest_payment\":null,\"co_pay\":null,\"co_ins\":null,\"deductible\":null,\"transfer_to\":\"Billing Department\",\"notes\":\"Follow-up appointment scheduled\",\"additional_adjustments_1\":0,\"additional_reason_type_1\":\"CO\",\"additional_adjustments_2\":0,\"additional_reason_type_2\":\"CO\",\"remark_codes\":\"PR\"}]}\n<|endoftext|>"}
{"prompt": "Provide the details and example schema for rendering an AdvancedFormNode Form.", "completion": "Explanation:\nNow lets cover the AdvancedFormNode schema which contains only Antd Form Fields thus it will contain on topOptions. The type of the field present inside the topOptions will be: select, multiselect, signature, number, text, date, asyncselect, asyncselectmulti, additional_data, multidate, image_capture. size determines the width occupied by the field 24 being the 100% width, required key determines if the field needs to be filled before submitting, default value will set the default values, is_read_only will determine if the field will be disabled or not. The select & multiselect field will need options, it will come either from options key or options_query key. defaultvalue for signature will come in the img key(this is one exception, also img is separate key, it is not part of defaultValue key). default value for date will be in string in mm/dd/yyyy format (on submit also the format is same, processing happens on the Frontend) Below I have provided comprehensive schema which contains the schema for each type. learn from it \nSchema:\n{\"topOptions\":[{\"default_value\":null,\"id\":\"1\",\"is_read_only\":null,\"label\":\"Doctor\",\"name\":\"doctor\",\"onchange\":null,\"options\":[{\"value\":\"doctor1\",\"display_value\":\"Doctor 1\"},{\"value\":\"doctor2\",\"display_value\":\"Doctor 2\"}],\"options_query\":null,\"order\":1,\"size\":24,\"type\":\"select\",\"required\":true},{\"default_value\":null,\"id\":\"2\",\"is_read_only\":false,\"label\":\"Period Type\",\"name\":\"period_type\",\"onchange\":null,\"options\":[{\"value\":\"weekdays\",\"display_value\":\"Weekdays\"},{\"value\":\"specific_dates\",\"display_value\":\"Specific Dates\"}],\"options_query\":null,\"order\":2,\"size\":24,\"type\":\"select\",\"required\":true},{\"default_value\":[],\"id\":\"3\",\"is_read_only\":false,\"label\":\"Select Days\",\"name\":\"select_weekdays\",\"onchange\":null,\"options\":[{\"value\":\"monday\",\"display_value\":\"Monday\"},{\"value\":\"tuesday\",\"display_value\":\"Tuesday\"},{\"value\":\"wednesday\",\"display_value\":\"Wednesday\"},{\"value\":\"thursday\",\"display_value\":\"Thursday\"},{\"value\":\"friday\",\"display_value\":\"Friday\"},{\"value\":\"saturday\",\"display_value\":\"Saturday\"},{\"value\":\"sunday\",\"display_value\":\"Sunday\"}],\"options_query\":null,\"order\":3,\"size\":24,\"type\":\"multiselect\",\"display\":\"none\",\"required\":true},{\"default_value\":null,\"id\":\"4\",\"is_read_only\":false,\"label\":\"Select Dates\",\"name\":\"select_dates\",\"onchange\":null,\"options\":null,\"options_query\":null,\"order\":4,\"size\":24,\"type\":\"multidate\",\"display\":\"none\",\"required\":true},{\"default_value\":null,\"id\":\"5\",\"is_read_only\":null,\"label\":\"Vendor\",\"name\":\"vendor_id\",\"onchange\":null,\"options_query\":\"query|select id, name from bakereye.vendors\",\"order\":5,\"size\":6,\"type\":\"select\",\"required\":true},{\"default_value\":null,\"id\":\"6\",\"is_read_only\":null,\"content\":\"Some Dummy T&C\",\"label\":\"Signature\",\"name\":\"signature\",\"onchange\":null,\"options\":null,\"options_query\":null,\"order\":6,\"size\":6,\"type\":\"signature\",\"required\":true},{\"default_value\":1,\"id\":\"7\",\"is_read_only\":false,\"label\":\"Quantity\",\"name\":\"quantity\",\"onchange\":null,\"options\":null,\"options_query\":null,\"order\":7,\"size\":2,\"type\":\"number\"},{\"default_value\":\"OEHOE9510391\",\"id\":\"8\",\"is_read_only\":false,\"label\":\"Subscriber id\",\"name\":\"subscriber_number\",\"onchange\":null,\"options\":null,\"options_query\":null,\"order\":8,\"required\":true,\"size\":6,\"type\":\"text\"},{\"default_value\":\"02/24/2018\",\"id\":\"9\",\"is_read_only\":null,\"label\":\"Subscriber DoB\",\"name\":\"subscriber_dob\",\"onchange\":null,\"options\":null,\"options_query\":null,\"order\":9,\"required\":true,\"size\":6,\"type\":\"date\"},{\"default_value\":null,\"id\":\"10\",\"is_read_only\":null,\"label\":\"Effective From\",\"name\":\"effective_from\",\"onchange\":null,\"options\":null,\"options_query\":null,\"order\":10,\"size\":6,\"type\":\"date\"},{\"id\":\"11\",\"name\":\"img_capture\",\"size\":6,\"type\":\"image_capture\",\"label\":\"Capture/Upload Image\",\"order\":11,\"options\":null,\"onchange\":null,\"is_read_only\":null,\"default_value\":null,\"required\":true},{\"default_value\":null,\"id\":\"12\",\"is_read_only\":null,\"label\":\"Additional Data\",\"name\":\"encounter_data\",\"onchange\":null,\"options\":[{\"display_value\":\"Insurance\",\"value\":\"insurance\"},{\"display_value\":\"Cash\",\"value\":\"cash\"}],\"options_query\":null,\"order\":12,\"required\":false,\"size\":4,\"type\":\"additional_data\"},{\"default_value\":null,\"id\":\"13\",\"is_read_only\":null,\"is_required\":false,\"label\":\"Referring Provider\",\"name\":\"referring_provider_name\",\"onchange\":null,\"options_query\":\"query|select input, input from spacenodelookup where identifier='referringprovider'\",\"order\":13,\"size\":6,\"type\":\"asyncselect\"},{\"default_value\":null,\"id\":\"14\",\"is_read_only\":null,\"label\":\"Diagnostic Codes\",\"name\":\"diagnostic_codes\",\"onchange\":null,\"options\":null,\"options_query\":null,\"order\":14,\"size\":6,\"type\":\"asyncselectmulti\"}]\n<|endoftext|>"}
{"prompt": "Provide the details and example schema for rendering an AdvancedFormNode Form.", "completion": "Explanation:\nNow lets learn about the schema for the antd form list. The form field for antd form list will come inside the listOptions key. each object in listOptions array will contain the schema for the field. select, text, number, randomuuid, random8digitbarcode, date, timerange are types of the field which antd form list can contain. Some nuances around schema is if we have a display key then rows key will be present for sure as rows: []. if the value of display is 'none' then the field is not renderred ( this is taken care by frontend code). if the field is select type options are computed using options or options_query key. Below im providing the schema of the listOptions. Learn from it\nSchema:\n{\"listOptions\":[{\"default_value\":null,\"id\":\"1\",\"is_read_only\":null,\"label\":\"Item Type\",\"name\":\"inventory\",\"onchange\":null,\"options\":[{\"display_value\":\"New SKU & New Item\",\"value\":\"1\"},{\"display_value\":\"Existing SKU & New Item\",\"value\":\"2\"},{\"display_value\":\"Existing SKU & Existing Item\",\"value\":\"3\"}],\"options_query\":null,\"order\":1,\"size\":3,\"type\":\"select\",\"required\":true},{\"default_value\":null,\"id\":\"10\",\"is_read_only\":null,\"label\":\"Product SKU\",\"name\":\"productsku_id\",\"onchange\":null,\"options_query\":\"query|select id, name from bakereye.productsku\",\"order\":10,\"size\":3,\"type\":\"select\",\"required\":true,\"display\":\"\",\"rows\":[]},{\"default_value\":null,\"id\":\"20\",\"is_read_only\":true,\"label\":\"Product SKU\",\"name\":\"productsku_new\",\"onchange\":null,\"options\":null,\"options_query\":null,\"order\":20,\"size\":3,\"type\":\"randomuuid\",\"required\":true,\"display\":\"\",\"rows\":[]},{\"default_value\":null,\"id\":\"20123\",\"is_read_only\":true,\"label\":\"Unique Barcode No.\",\"name\":\"unique_barcode_no\",\"onchange\":null,\"options\":null,\"options_query\":null,\"order\":21,\"size\":3,\"type\":\"random8digitbarcode\",\"required\":true,\"display\":\"\"},{\"default_value\":null,\"id\":\"40\",\"is_read_only\":true,\"label\":\"Item No.\",\"name\":\"item_number_new\",\"onchange\":null,\"options\":null,\"options_query\":null,\"order\":40,\"size\":3,\"type\":\"text\",\"display\":\"\",\"rows\":[]},{\"default_value\":1,\"id\":\"60\",\"is_read_only\":false,\"label\":\"Quantity\",\"name\":\"quantity\",\"onchange\":null,\"options\":null,\"options_query\":null,\"order\":60,\"size\":2,\"type\":\"number\"},{\"default_value\":null,\"id\":\"100\",\"is_read_only\":false,\"label\":\"Color\",\"name\":\"color\",\"onchange\":null,\"options\":null,\"options_query\":null,\"order\":100,\"size\":3,\"type\":\"text\",\"display\":\"\",\"rows\":[]},{\"default_value\":null,\"id\":\"3\",\"is_read_only\":null,\"label\":\"Date of Service\",\"name\":\"date_of_service\",\"onchange\":null,\"options\":null,\"options_query\":null,\"order\":3,\"size\":3,\"type\":\"date\",\"display\":\"none\",\"rows\":[]},{\"default_value\":null,\"id\":\"100\",\"is_read_only\":null,\"label\":\"Date From\",\"name\":\"date_from\",\"onchange\":null,\"options\":null,\"options_query\":null,\"order\":100,\"size\":3,\"type\":\"date\",\"required\":true},{\"default_value\":null,\"id\":\"101\",\"is_read_only\":false,\"label\":\"Schedule Time\",\"name\":\"timerange\",\"onchange\":null,\"options\":null,\"options_query\":null,\"order\":101,\"size\":12,\"type\":\"timerange\",\"required\":true}]\n<|endoftext|>"}
{"prompt": "Provide a general explanation about the dependencies in AdvancedFormNode", "completion": "Explanation:\nNow along with topOptions, listOptions, defaultColumns and tableData we have a key named as dependencies. dependencies is array of objects as well. Each object can represent the schema of one the dependency type. In total we have following dependencies: - validation - transformation - topOptionDependency - listOptionDependency - enableListOptionDependency - tableRowTransformation - onLoadDependency For general explanation: lets suppose we have a advancedformnode rendered where the input schema contained topOptions, defaultColumns and tableData thus antd form and antd table was rendered. Now user can make changes to the antd form fields as well the antd table for the columns which were editable. As and when user makes this changes the frontend code of advancedformnode executes the code in the dependencies, and based on the code provided in dependencies the value of the targetfields mentioned in dependency is changed. we want to cover each dependency one by one. I will give you training data for one dependency along with the explanation of how it works and you need to train on the data and learn how that particular dependency work and after that whenever I give you scenario for developing a dependency you should be give me response for the same in the correct json schema.\n<|endoftext|>"}
{"prompt": "Explain the tableRowTransformation dependency along with its dependency schema", "completion": "Explanation:\nLets start with tableRowTransformation dependency type. each tableRowTransformation dependency will contain type(tableRowTransformation), dependantFields(array of objects, optional key), targetFields(array of object, mostly it contains only one object) tableRowTransformation works in a way that whenever user makes changes to one the field mentioned in the dependentFields the function inside the targetFields is executed and new value of the the row the is returned and these value becomes visible in the advancedformnode. If the dependency doesn’t contain dependentFields the function inside the targetFields is executed automatically. The function inside targetFields can take three arguments 1. current row value 2. reqdFieldValues 3. oldRow value. Now the value for the current row value and old row value can be different because we run the dependency in the loop and the output of the first executed dependency is taken as the current row value while the old row is before any user manipulation, reqdFieldValue will be array of one object, the object will contain only one key and that will be one of the dependentField which was changed by the user. Below I will be providing the schema train from it. whenever we are working with tableRowTransformation by default we add one dependency at the top whose code is: { type: 'tableRowTransformation', targetFields: [ { function: 'function (row, reqdFieldValues) {return row;}' } ] }, Also make sure that for the other tableRowTransformations containing dependentFields we are checking that Object.values(reqdFieldValues[0])[0] is not null or undefined, if this is the case directly return null.
\nSchema:\n{\"dependencies\":[{\"type\":\"tableRowTransformation\",\"targetFields\":[{\"function\":\"function (row, reqdFieldValues) {return row;}\"}],\"dependentFields\":[]},{\"type\":\"tableRowTransformation\",\"targetFields\":[{\"function\":\"function(row, reqdFieldValues, oldRow) { let newCopay = row['co_pay'] ? row['co_pay'] : 0; let newCoins = row['co_ins'] ? row['co_ins'] : 0; let newDed = row['deductible'] ? row['deductible'] : 0; let newAdj1 = row['additional_adjustment_1'] ? row['additional_adjustment_1'] : 0; let newAdj2 = row['additional_adjustment_2'] ? row['additional_adjustment_2'] : 0; let newTotalBalance = parseFloat((newCopay + newCoins + newDed + newAdj1 + newAdj2).toFixed(2)); let payments = 0; let val = Object.values(reqdFieldValues[0])[0]; if(val === undefined) { return row;} else { let newAllowed = row['allowed'] ? row['allowed'] : 0; payments = parseFloat((newAllowed - newTotalBalance).toFixed(2)); return {...row, payments, total_balance: newTotalBalance};}}\",\"fieldType\":\"tableColumn\"}],\"dependentFields\":[{\"fieldType\":\"tableColumn\",\"fieldDataIndex\":\"co_pay\"},{\"fieldType\":\"tableColumn\",\"fieldDataIndex\":\"co_ins\"},{\"fieldType\":\"tableColumn\",\"fieldDataIndex\":\"deductible\"},{\"fieldType\":\"tableColumn\",\"fieldDataIndex\":\"additional_adjustment_1\"},{\"fieldType\":\"tableColumn\",\"fieldDataIndex\":\"additional_adjustment_2\"}]},{\"type\":\"tableRowTransformation\",\"targetFields\":[{\"function\":\"function (row, reqdFieldValues) {if ( reqdFieldValues !== null && reqdFieldValues !== undefined && reqdFieldValues.length > 0) {if (row.allowed === undefined) {return row;} else { let co_pay = row.co_pay ? row.co_pay : 0; let co_ins = row.co_ins ? row.co_ins : 0; let deductible = row.deductible ? row.deductible : 0; let balance = row.balance ? row.balance : 0; let add1 = row.additional_adjustment_1 ? row.additional_adjustment_1 : 0; let add2 = row.additional_adjustment_2 ? row.additional_adjustment_2 : 0; return { ...row, payments: parseFloat((row.allowed - co_pay - co_ins - deductible - add1 - add2).toFixed(2)), unallowed: parseFloat((balance - row.allowed).toFixed(2)) };}}}\",\"fieldType\":\"tableColumn\"}],\"dependentFields\":[{\"fieldType\":\"tableColumn\",\"fieldDataIndex\":\"allowed\"}]}]}\n<|endoftext|>"}
{"prompt": "Explain the validation dependency along with its dependency schema", "completion": "Explanation:\nNow lets work with the validation dependency type. Similar to tableRowTransformation the validation dependency will be present inside the dependencies key as an object. For the validation dependency there will mainly be following keys. - type (validation) - ⁠checkType (hard or soft) - ⁠targetFields(array of objects) - ⁠dependentFields(array of object) there can be cases in which all the fields might not present, you need to pay attention to such details. for example when the validation is related to targetFields being the tableColumn dependentFields might not be present. Generally the each targetFields object will contain fieldType, fieldName, ruleSchema / message and function. dependentFields object can contain fieldType and fieldDataIndex key, for the fieldType ListOption if we dont have fieldDataIndex that is fine. if the targetFields contain ruleSchema it will adhere to rules config from the ant design. When there is function you should notice that the function will return a boolean, if the function is returning true then in the frontend an error will be prompted. Below I’m providing schema which covers all the cases, pay great attention on different nuances when we are dealing with a tableColumn, topOption and listOption. You need to keep that in mind\nSchema:\n{\"dependencies\":[{\"type\":\"validation\",\"checkType\":\"hard\",\"targetFields\":[{\"fieldType\":\"tableColumn\",\"fieldName\":\"paidAmt\",\"ruleSchema\":{\"type\":\"number\",\"min\":0,\"message\":\"Paid Amount can't be less than 0\"}},{\"fieldType\":\"tableColumn\",\"fieldName\":\"adjustment1\",\"ruleSchema\":{\"type\":\"number\",\"min\":0,\"message\":\"Adjustment1 can't be less than 0\"}},{\"fieldType\":\"tableColumn\",\"fieldName\":\"adjustment2\",\"ruleSchema\":{\"type\":\"number\",\"min\":0,\"message\":\"Adjustment2 can't be less than 0\"}}]},{\"type\":\"validation\",\"checkType\":\"hard\",\"dependentFields\":[{\"fieldType\":\"topOption\",\"fieldDataIndex\":\"paymentType\",\"fieldValue\":\"Cheque\"}],\"targetFields\":[{\"fieldType\":\"topOption\",\"fieldName\":\"chequeAmt\",\"ruleSchema\":{\"type\":\"number\",\"max\":1000,\"message\":\"Max value 1000\"}}]},{\"type\":\"validation\",\"checkType\":\"hard\",\"dependentFields\":[{\"fieldType\":\"listOption\"}],\"targetFields\":[{\"fieldType\":\"listOption\",\"fieldName\":\"total_charges\",\"message\":\"Total Charges should be equal to Insurance Charges + Patient Charges\",\"function\":\"function (value, currentItem) { let tot = value ? value : 0; let ins = currentItem.insurance_charges ? currentItem.insurance_charges : 0; let pat = currentItem.patient_charges ? currentItem.patient_charges : 0; return (tot !== (pat + ins))}\"},{\"fieldType\":\"listOption\",\"fieldName\":\"insurance_charges\",\"message\":\"Total Charges should be equal to Insurance Charges + Patient Charges\",\"function\":\"function (value, currentItem) { let ins = value ? value : 0; let tot = currentItem.total_charges ? currentItem.total_charges : 0; let pat = currentItem.patient_charges ? currentItem.patient_charges : 0; return (tot !== (pat + ins))}\"},{\"fieldType\":\"listOption\",\"fieldName\":\"patient_charges\",\"message\":\"Total Charges should be equal to Insurance Charges + Patient Charges\",\"function\":\"function (value, currentItem) { let pat = value ? value : 0; let ins = currentItem.insurance_charges ? currentItem.insurance_charges : 0; let tot = currentItem.total_charges ? currentItem.total_charges : 0; return (tot !== (pat + ins))}\"}]},{\"type\":\"validation\",\"checkType\":\"hard\",\"dependentFields\":[{\"fieldType\":\"listOption\"}],\"targetFields\":[{\"fieldType\":\"listOption\",\"fieldName\":\"subscriber_zip\",\"message\":\"Only Numbers Allowed.\",\"function\":\"function (value, currentItem) { return isNaN(Number(value));}\"}]},{\"type\":\"validation\",\"checkType\":\"hard\",\"dependentFields\":[{\"fieldType\":\"topOption\",\"fieldDataIndex\":\"patient_address_zip\"}],\"targetFields\":[{\"fieldType\":\"topOption\",\"fieldName\":\"patient_address_zip\",\"message\":\"Only Numbers Allowed.\",\"function\":\"function (value) { return isNaN(Number(value));}\"}]}]}\n<|endoftext|>"}
{"prompt": "Explain onLoadDependency dependency along with the dependency schema", "completion": "Explanation:\nNow lets move to onLoadDependency. This dependency object will contain only two keys. 1. type (onLoadDependency) 2. targetFields. targetFields is array and it will contain only one object. onLoadDependency is specifically for the topOptions. This dependency is called inside the useEffect. Thus it is used to setup the updated value for the topOptions. The function will either return new top options or an object with keys newTop and newsigns the function will take in three arguments, first represents topOptions, second represents signdata third represent tableData. you should add three argument in your output irrespective of them being used. this function can check the default value of any field and do some changes such as changing display key to '' (previously it would have 'none' thus the field was not rendered) or it can loop over table data do some process and return updated top options or it can also contain signdata and we need to return topoptions and signdata, if dependency is regarding signdata then we need to update the ref for sure using the line signatureRefs['signature'].current = 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAZAAAADIAAAXJggg=='; here I will give the image metadata based on my requirement and that needs to be used. based on the dependencies provided below learn from them\nSchema:\n{\"dependencies\":[{\"targetFields\":[{\"fieldDataIndex\":\"health_plan\",\"fieldType\":\"topOption\",\"function\":\"function(topOptions) { let newTop = topOptions; let financial_class = newTop.find(item => item.name === 'financial_class'); if (financial_class.default_value === 'HMO' || financial_class.default_value === 'MEDI-CAL HMO') { newTop = newTop.map(item => { if(item.name === 'health_plan') {return { ...item, display: ''} } else {return item; }}); return newTop; } else { return newTop; }}\"}],\"type\":\"onLoadDependency\"},{\"type\":\"onLoadDependency\",\"targetFields\":[{\"fieldType\":\"topOption\",\"fieldDataIndex\":\"primary_insurance\",\"function\":\"function(topOptions) { let newTop = topOptions; let pay_type = newTop.find(item => item.name === 'pay_type'); if (pay_type.default_value === '1') { newTop = newTop.map(item => { if(item.name === 'primary_insurance') {return { ...item, display: ''} } else {return item; }}); return newTop; } else { return newTop; }}\"}]},{\"type\":\"onLoadDependency\",\"targetFields\":[{\"fieldType\":\"topOption\",\"fieldDataIndex\":\"secondary_insurance\",\"function\":\"function(topOptions) { let newTop = topOptions; let pay_type = newTop.find(item => item.name === 'pay_type'); if (pay_type.default_value === '1') { newTop = newTop.map(item => { if(item.name === 'secondary_insurance') {return { ...item, display: ''} } else {return item; }}); return newTop; } else { return newTop; }}\"}]},{\"targetFields\":[{\"fieldDataIndex\":\"totalPayments\",\"fieldType\":\"topOption\",\"function\":\"function (topOptions, signData, tabData) { let newTop = topOptions; let i = 0; tabData.forEach((el) => { if (!isNaN(el.payments) && el.payments !== undefined && el.payments !== null) { i = i + el.payments;}}); if (isNaN(i) || i === undefined || i === null) { return newTop; } else { newTop = newTop.map((item) => { if (item.name === 'totalPayments') { return { ...item, default_value: i }; } else { return item; } }); return newTop; }}\"}],\"type\":\"onLoadDependency\"},{\"type\":\"onLoadDependency\",\"targetFields\":[{\"fieldType\":\"topOption\",\"fieldDataIndex\":\"signature\",\"function\":\"function (topOptions, signData) { let newTop = topOptions; let newsigns = signData; newsigns = {...newsigns, signature: 'data:image/png;base64,wAAAABJRU5ErkJggg=='}; signatureRefs['signature'].current = 'data:image/png;base64,wAAAABJRU5ErkJggg=='; return {newTop, newsigns};}\"}]}]}\n<|endoftext|>"}
{"prompt": "Explain listOptionDependency along with its dependency schema", "completion": "Explanation:\nNow lets take the listOptionDependency. This dependency will contains 3 keys. 1. type (listOptionDependency) 2. targetFields(array of objects, only one object will be present), dependentFields(array of objects, for sure only one object will be present whose value will be { fieldType: 'listOption’, fieldDataIndex: 'listOptions' }).As the name suggest this dependency is executed only when the user has made any changes in the antd form list which is rendered using listOptions from the input schema, additionally you should also know that the name of the antd form list in the advancedformnode is listOptions thus whole data of the antd form list manipulated by the user is stored in listOptions key.The main aim of this dependency is to manipulate the current values of the antd form list in advancedformnode based on the user action in the listOptions(antd form list). As the user is manipulating antd form list the value for the whole form list is the array of objects where each object is representing the a particular row in the antd form list. all the rows will have the same object keys while the values will be different based on the user input. So in the schema targetFields will contain only one object and that object will contain fieldType, fieldDataIndex and function. value for the fieldType and fieldDataIndex will be listOptions for sure. while function will be the javascript function which will determine the new value for the listOptions Mostly this dependency is used to manage if a particular listOption field should be displayed for the particular row or not based on the user input, the keys display and rows are used for this. if display is none of the rows doesnt contain the index of the list index for the particular field then we won’t display the field for the particular list row. The typical function in targetFields contains three arguments 1. changedValue 2. listOptions from the input schema 3. antd form list value (this is also named as listOptions), so net net 2nd argument determines what fields to show for antd form list and 3rd argument contains the data for the antd form list in the advancedformnode, in the function we determine which particular row was modified by the user and then based on the value of the field which was changed we run some conditional suiting the requirement. Below im pasting the dependencies which contains listOptionDependency type, I will explain the first dependency, the function inside the first dependency, lets assume currently there are 4 rows for the antd form list and now the user made change for the third row for the financial_class field, so the function is checking if the financial_class field was updated or not, if it wasnt updated we are directly returning the listOptions without any change if the financial_class was changed and the value was updated to 1 then we are looping over the listOptions(input schema) when we encounter the health_plan_name field we are making sure for all the rows of the antd form list that health_plan_name is displayed by returning: return { ...option, display: '', rows: newRows };, if financial_class is not equal to 1 we are making sure that the antd form list rows for which were not updated and the financial_class value is 1 keep displaying the health_plan_name field and the for the rows not having financial_class as 1 dont show health_plan_nameNow study the below schema for the listOptionDependencies, learn from it, follow the structure\nSchema:\n{\"dependencies\":[{\"type\":\"listOptionDependency\",\"dependentFields\":[{\"fieldType\":\"listOption\",\"fieldDataIndex\":\"listOptions\"}],\"targetFields\":[{\"fieldType\":\"listOptions\",\"fieldDataIndex\":\"listOptions\",\"function\":\"function (changedValues, listOps, listVals) { let newList = listOps; let index = changedValues.listOptions.length - 1; if ( changedValues.listOptions[index]?.financial_class !== undefined && changedValues.listOptions[index]?.financial_class !== null) { if (changedValues.listOptions[index]?.financial_class === '1') { newList = newList.map((option) => { if (option.name === 'health_plan_name') { let newDep = listVals; let newRows = []; for (var i = 0; i < newDep.length; i++) { if (newDep[i].financial_class === '1') { newRows.push(i); }} return { ...option, display: '', rows: newRows }; } else { return option;}});return newList;} else { newList = newList.map((option) => { if (option.name === 'health_plan_name') { let newDep = listVals; let newRows = []; for (var i = 0; i < newDep.length; i++) { if (newDep[i].financial_class === '1') {newRows.push(i);}} if (newRows.length > 0) { return { ...option, display: '', rows: newRows};} return { ...option, display: 'none', rows: newRows };} else { return option; } });return newList; } } else {return newList; }}\"}]},{\"type\":\"listOptionDependency\",\"dependentFields\":[{\"fieldType\":\"listOption\",\"fieldDataIndex\":\"listOptions\"}],\"targetFields\":[{\"fieldType\":\"listOptions\",\"fieldDataIndex\":\"listOptions\",\"function\":\"function (changedValues, listOps, listVals) { let newList = listOps; let index = changedValues.listOptions.length - 1; if ( changedValues.listOptions[index]?.inventory !== undefined && changedValues.listOptions[index]?.inventory !== null ) { newList = newList.map((option) => { if (option.name === 'productsku_new') { let newDep = listVals; let newRows = []; for (var i = 0; i < newDep.length; i++) { if (newDep[i].inventory === '1') { newRows.push(i); } } return { ...option, display: '', rows: newRows }; } else if (option.name === 'item_number') { let newDep = listVals; let newRows = []; for (var i = 0; i < newDep.length; i++) { if (newDep[i].inventory === '3') { newRows.push(i); } } return { ...option, display: '', rows: newRows }; } else if (option.name === 'productsku_id') { let newDep = listVals; let newRows = []; for (var i = 0; i < newDep.length; i++) { if ( newDep[i].inventory === '2' || newDep[i].inventory === '3' ) { newRows.push(i); } } return { ...option, display: '', rows: newRows }; } else if ( option.name === 'retail_price' || option.name === 'color' || option.name === 'size' || option.name === 'item_number_new' ) { let newDep = listVals; let newRows = []; for (var i = 0; i < newDep.length; i++) { if ( newDep[i].inventory === '2' || newDep[i].inventory === '1' ) { newRows.push(i); } } return { ...option, display: '', rows: newRows }; } else { return option; } }); return newList; } else { return newList; }}\"}]},{\"type\":\"listOptionDependency\",\"dependentFields\":[{\"fieldType\":\"listOption\",\"fieldDataIndex\":\"listOptions\"}],\"targetFields\":[{\"fieldType\":\"listOptions\",\"fieldDataIndex\":\"listOptions\",\"function\":\"function (changedValues, listOps, listVals) { let newList = listOps; let index = changedValues.listOptions.length - 1; if ( changedValues.listOptions[index]?.procedure_code !== undefined && changedValues.listOptions[index]?.procedure_code !== null) { if (changedValues.listOptions[index]?.procedure_code === '1') { newList = newList.map((option) => { if (option.name === 'date_of_service') { let newDep = listVals; let newRows = []; for (var i = 0; i < newDep.length; i++) { if (newDep[i].procedure_code === '1') { newRows.push(i); }} return { ...option, display: '', rows: newRows }; } else { return option;}});return newList;} else { newList = newList.map((option) => { if (option.name === 'date_of_service') { let newDep = listVals; let newRows = []; for (var i = 0; i < newDep.length; i++) { if (newDep[i].procedure_code === '1') {newRows.push(i);}} if (newRows.length > 0) { return { ...option, display: '', rows: newRows};} return { ...option, display: 'none', rows: newRows };} else { return option; } });return newList; } } else {return newList; }}\"}]}]}\n<|endoftext|>"}
{"prompt": "Explain enableListOptionDependency along with its dependency schema", "completion": "Explanation:\nNow lets take enableListOptionDependency. This dependency is used when we want to display antd form list only when the user selects a particular value for a field in the antd form. enableListOptionDependency have similar schema with three keys. 1. type (enableListOptionDependency) 2. dependentFields (array of objects, it will contain only one object with two keys fieldType as topOption compulsorily and fieldDataIndex). 3. targetFields(array of objects, only one object will be present for sure with two keys fieldType whose value will always be listOptions and other key will be function). The function inside the targetFields takes in changedValues. This changedValues will be basically the change user would have made in the antd form field. This function will only be called in the antd form field which was changed by the user is present in the dependentFields. Now when the function is called the logic is executed and depending on the changed value of the antd form field a boolean is returned. if true is returned than antd form list will be rendered on the screen. Now below i’m providing the dependencies key which contains enableListOptionDependency. Learn from it\nSchema:\n{\"dependencies\":[{\"type\":\"enableListOptionDependency\",\"dependentFields\":[{\"fieldType\":\"topOption\",\"fieldDataIndex\":\"period_type\"}],\"targetFields\":[{\"fieldType\":\"listOptions\",\"function\":\"function (changedValues) { let period_type = changedValues.period_type; if (period_type) { return true; } else { return false; }}\"}]}]}\n<|endoftext|>"}
{"prompt": "Explain topOptionDependency along with its dependency schema", "completion": "Explanation:\nNow lets take topOptionDependency. It is similar to listOptionDependency. The schema will have 3 keys 1. type(topOptionDependency)2. dependentFields(array of object, only one object will be present where the object will contain 2 keys. 1. fieldType whose value will be topOption always and second fieldDataIndex)3. targetFields(array of objects, where there will always be one object with three keys 1. fieldType whose value will always be topOption,2. fieldDataIndex, 3. function) Whenever the user changed the field whose fieldDataIndex matches with the object inside the dependentFields the function inside the targetFields is called. the function inside targetFields contains changedValues and topOptions as the argument where topOptions is the topOptions schema provided in input to render the antd form, the changedValues will contain the changed Value of the dependentField whose fieldDataIndex has matched. What function basically do is it checks for the changedValue and based on the changed value it decides if one the other topOption field should be displayed or not. if display = ‘none’ field will not be rendered and if display = '' field will be rendered. So the conditional logic is present inside the function. Below I’m providing the dependencies which contains certain topOptionDependencies. I want you to train\nSchema:\n{\"dependencies\":[{\"dependentFields\":[{\"fieldDataIndex\":\"financial_class\",\"fieldType\":\"topOption\"}],\"targetFields\":[{\"fieldDataIndex\":\"health_plan\",\"fieldType\":\"topOption\",\"function\":\"function(changedValues, topOptions) {let financial_class = changedValues.financial_class;let newTop = topOptions;if (financial_class === 'HMO' || financial_class === 'MEDI-CAL HMO') {newTop = newTop.map((option) => {if (option.name === 'health_plan') {return { ...option, display: ''}} else {return option;}}); return newTop;} else {newTop = newTop.map((option) => {if (option.name === 'health_plan') {return { ...option, display: 'none'}} else {return option;}});return newTop;}}\"}],\"type\":\"topOptionDependency\"},{\"type\":\"topOptionDependency\",\"dependentFields\":[{\"fieldType\":\"topOption\",\"fieldDataIndex\":\"appointment_mode\"}],\"targetFields\":[{\"fieldType\":\"topOption\",\"function\":\"function (changedValues, topOptions) {let appointment_mode = changedValues.appointment_mode;let newTop = topOptions;if (appointment_mode === '1') {newTop = newTop.map((option) => {if (option.name === 'upload') {return { ...option, display: ''}} else if (option.name !== 'appointment_mode' && option.name !== 'upload') {return { ...option, display: 'none' }} else {return option;}});return newTop;} else if (appointment_mode === '2') {newTop = newTop.map((option) => {if (option.name === 'upload') {return { ...option, display: 'none'}} else if (option.name !== 'appointment_mode' && option.name !== 'upload') {return { ...option, display: '' }} else {return option;}});return newTop;} else {newTop = newTop.map((option) => {if (option.name === 'appointment_mode') {return option;} else {return { ...option, display: 'none'}}});return newTop;}}\"}],\"type\":\"topOptionDependency\"},{\"dependentFields\":[{\"fieldDataIndex\":\"period_type\",\"fieldType\":\"topOption\"}],\"targetFields\":[{\"fieldType\":\"topOption\",\"function\":\"function(changedValues, topOptions) {let period_type = changedValues.period_type;let newTop = topOptions;if (period_type === 'weekdays') {newTop = newTop.map((option) => {if (option.name === 'select_weekdays') {return { ...option, display: ''}} else if (option.name === 'select_dates') {return {...option, display: 'none'}} else {return option;}}); return newTop;} else if (period_type === 'specific_dates') {newTop = newTop.map((option) => {if (option.name === 'select_weekdays') {return { ...option, display: 'none'}} else if (option.name === 'select_dates') {return {...option, display: ''}} else {return option;}}); return newTop;} else {return newTop;}}\"}],\"type\":\"topOptionDependency\"}]}\n<|endoftext|>"}
{"prompt": "", "completion": "Explanation:\nNow lets take the last dependency, “transformation”. This dependency has capacity to directly update the form or form list or table element. Thus if any requirement comes which deals with updating the value of the field instead of modifying the input schema dependency type transformation is the go to place. Syntax is quite similar to other dependencies. Contains 3 keys. - type (equals to transformation) - dependentFields - targetFields dependentFields is array of objects and can contain multiple objects inside it. Each object contains two keys fieldType and fieldDataIndex, if fieldType is tableColumn then there wont be fieldDataIndex other for when fieldType is listOption fieldDataIndex is compulsorily listOptions and when fieldType is topOption the fieldDataIndex is the field name which is of the interest. Whenever the user modifies any of the field from the form or form list or the table present inside the dependentFields function inside the targetFields is executed. targetFields like dependentFields is array of objects. each object will contain fieldType, fieldDataIndex and function. the function will take 10 arguments, make sure to include them even if we are not using all of them. the arguments are changedValues(latest changed field key value is present here, also note that the dependency was triggered because of editing this field and this field will be present in the ), reqdFieldValues (contains the details of all the dependentFields inside it), targetValue(current value of the field of interest for whom this dependency is calculating updated value), allValues(this is a form instance which contains data about all form fields, form list fields and table data), schema(input schema for advancedformnode), dataSource(data present for the table), moment (js library), record(some data stored in localStorage), spaceSlug, workspaceId (spaceSlug and workspaceId are related to identifying the route which is rendering the advancedformnode) the function in targetFields returns the value for the fieldDataIndex for the particular targetFields object. whenever any one of the dependentFields is updated by user for a particular dependency all the objects inside the targetFields will be executed one by one. One thing to note here for you is if targetFields contains 3 objects then the output from the first object is input for the second and output of second is input for the third. So net net there can be multiple dependentFields, multiple targetFields, dependency will be executed if user changes one of the dependentFields, once called all the targetFields objects will be processed. and each function of the targetFields returns a targetValue which is the latest updated value for the fieldDataIndex for the same targetFields object. inside the function we basically check the data from the arguments and based on certain conditions finalize the return value. in targetFields we can have fieldType listOption, fieldDataIndex as listOptions and fieldType as topOption and fieldDataIndex as one of the form field. the dependency can handle updating both types. The function can also call an api inside it. if api will be called then value of function will start with async. Below I’m pasting the training data, the training data contains 5 dependencies. Learn from it so that you can build these type of schema on your on Description of the dependencies: what function does for the first dependency: 1.	Checks if the user added or modified an entry in listOptions or changed one of the top-level patient fields (first name, last name, etc.). 	2.	If a new list item has subscriber_relationship === 'self', it copies patient details from the top-level form fields (patient_first_name, patient_last_name, etc.) into that new list item (e.g., for an insurance subscriber who is the same as the patient). 	3.	If an existing patient detail (like dob or gender) changes and a list item has subscriber_relationship === 'self', it updates that list item with the newly changed detail. 	4.	If the relationship is not ‘self’, it leaves the list item alone. 	5.	Returns the updated listOptions array so the form/list is in sync with the latest top-level patient data. what function does for the second dependency: 	1.	Whenever a table column changes (e.g., the user edits a cell in the table), this function is triggered. 	2.	It loops through the dataSource (which represents all rows in the table) and sums up certain numeric fields—in this example, payments and interest_payment. 	3.	It carefully checks each value to ensure it’s a valid number (not NaN, not undefined, etc.). 	4.	Finally, it returns the total as the new value of totalPayments. This effectively displays or stores the sum of all payment-related columns from the table in one top-level field. What function does for the third dependency: 1.	Triggered whenever the user edits any row inside listOptions (for instance, adding a procedure code). 	2.	If a newly changed field is procedure_code, the function calls an API (using fetch) to get additional information (e.g., total_charges). 	3.	On a successful API response, it updates the last-edited row in listOptions by setting the total_charges (or any relevant field) to the value returned from the server. 	4.	If procedure_code is missing or the fetch fails, it simply returns the current listOptions unmodified. 	5.	Because it’s marked as async, it can wait for the server response before finalizing the updated list data. What function does for the fourth dependency: 	1.	Watches for any change to subscriber_relationship in the form. 	2.	If subscriber_relationship === 'self', it copies subscriber data from some record (often referencing stored patient info) to each of the target fields: subscriber_first_name, subscriber_last_name, etc. 	3.	If subscriber_relationship !== 'self', it clears or resets these subscriber fields (e.g., sets them to empty). 	4.	Returns the new value to be stored in each target field, ensuring that subscriber fields are always in sync with the chosen relationship. What the functions do for fifth dependency: 	•	For listOptions (first function): 	1.	Whenever a row in listOptions changes (e.g., quantity or unit_cost), it recalculates total_cost for that row (total_cost = quantity * unit_cost). 	2.	If any of the required numbers is null or undefined, it sets total_cost to null so the user sees an empty or reset value. 	3.	Returns the updated array of list items. 	•	For total_price (second function): 	1.	Gathers all rows in listOptions, sums up each row’s unit_cost * quantity. 	2.	Returns the grand total of those costs to display or store in total_price. 	•	For total_quantity (third function): 	1.	Similarly scans all items in listOptions and adds up each row’s quantity value. 	2.	Returns that sum as the new total quantity.\nSchema:\n{\"dependencies\":[{\"type\":\"transformation\",\"dependentFields\":[{\"fieldType\":\"listOption\",\"fieldDataIndex\":\"listOptions\"},{\"fieldType\":\"topOption\",\"fieldDataIndex\":\"patient_first_name\"},{\"fieldType\":\"topOption\",\"fieldDataIndex\":\"patient_last_name\"},{\"fieldType\":\"topOption\",\"fieldDataIndex\":\"patient_middle_name\"},{\"fieldType\":\"topOption\",\"fieldDataIndex\":\"dob\"},{\"fieldType\":\"topOption\",\"fieldDataIndex\":\"gender\"},{\"fieldType\":\"topOption\",\"fieldDataIndex\":\"patient_address_1\"},{\"fieldType\":\"topOption\",\"fieldDataIndex\":\"patient_address_city\"},{\"fieldType\":\"topOption\",\"fieldDataIndex\":\"patient_address_state\"},{\"fieldType\":\"topOption\",\"fieldDataIndex\":\"patient_address_zip\"}],\"targetFields\":[{\"fieldType\":\"listOption\",\"fieldDataIndex\":\"listOptions\",\"function\":\"function (changedValues, reqdFieldValues, targetValue, allValues, schema, dataSource, moment, record, spaceSlug, workspaceId) { if (changedValues.listOptions) {let len = changedValues.listOptions.length; let lo = changedValues.listOptions[len -1]; if (lo && lo.subscriber_relationship && lo.subscriber_relationship === 'self') {const firstNameObj = reqdFieldValues.find(item => item.patient_first_name); const lastNameObj = reqdFieldValues.find(item => item.patient_last_name); const middleNameObj = reqdFieldValues.find(item => item.patient_middle_name); const dobObj = reqdFieldValues.find((item) => item.dob); const sexObj = reqdFieldValues.find((item) => item.gender); const addObj = reqdFieldValues.find(item => item.patient_address_1); const cityObj = reqdFieldValues.find((item) => item.patient_address_city); const stateObj = reqdFieldValues.find((item) => item.patient_address_state); const zipObj = reqdFieldValues.find((item) => item.patient_address_zip); let tv = targetValue?.map((el, i) => { if (i === len - 1) { return {...el, subscriber_last_name: lastNameObj ? lastNameObj.patient_last_name : null, subscriber_first_name: firstNameObj ? firstNameObj.patient_first_name : null, subscriber_middle_name: middleNameObj ? middleNameObj.patient_middle_name : null, subscriber_dob: dobObj ? dobObj.dob : null, subscriber_gender: sexObj ? sexObj.gender : null, subscriber_address: addObj ? addObj.patient_address_1 : null, subscriber_city: cityObj ? cityObj.patient_address_city : null, subscriber_state: stateObj ? stateObj.patient_address_state : null, subscriber_zip: zipObj ? zipObj.patient_address_zip : null}} else { return el; }}); return tv; } else { return targetValue; }} else { let newVal = changedValues.patient_first_name ? changedValues.patient_first_name : changedValues.patient_last_name ? changedValues.patient_last_name : changedValues.patient_middle_name ? changedValues.patient_middle_name : changedValues.dob ? changedValues.dob : changedValues.gender ? changedValues.gender : changedValues.patient_address_1 ? changedValues.patient_address_1 : changedValues.patient_address_city ? changedValues.patient_address_city : changedValues.patient_address_state ? changedValues.patient_address_state : changedValues.patient_address_zip ? changedValues.patient_address_zip : null; let newField = changedValues.patient_first_name ? 'subscriber_first_name' : changedValues.patient_last_name ? 'subscriber_last_name' : changedValues.patient_middle_name ? 'subscriber_middle_name' : changedValues.dob ? 'subscriber_dob' : changedValues.gender ? 'subscriber_gender' : changedValues.patient_address_1 ? 'subscriber_address' : changedValues.patient_address_city ? 'subscriber_city' : changedValues.patient_address_state ? 'subscriber_state' : changedValues.patient_address_zip ? 'subscriber_zip' : null; if (newVal && newField) {let tv = targetValue?.map((el) => { if (el.subscriber_relationship === 'self') {return {...el, [newField]: newVal} } else { return el; }}); return tv;} else { return targetValue; }}}\"}]},{\"type\":\"transformation\",\"targetFields\":[{\"function\":\"function (changedValues, reqdFieldValues, targetValue, allValues, schema, dataSource, moment, record, work) { let i=0; dataSource.forEach(el => { if (!isNaN(el.payments) && el.payments !== undefined && el.payments !== null) { i = parseFloat((i + el.payments).toFixed(2));} if (!isNaN(el.interest_payment) && el.interest_payment !== undefined && el.interest_payment !== null) { i = parseFloat((i + el.interest_payment).toFixed(2));}}); return i;}\",\"fieldType\":\"topOption\",\"fieldDataIndex\":\"totalPayments\"}],\"dependentFields\":[{\"fieldType\":\"tableColumn\"}]},{\"type\":\"transformation\",\"dependentFields\":[{\"fieldType\":\"listOption\",\"fieldDataIndex\":\"listOptions\"}],\"targetFields\":[{\"fieldType\":\"listOption\",\"fieldDataIndex\":\"listOptions\",\"function\":\"async function name(changedValues, reqdFieldValues, targetValue, allValues, schema, dataSource, moment, record, spaceSlug, workspaceId) { let len = changedValues.listOptions.length; let val = changedValues.listOptions[len - 1]; let key = val ? Object.keys(val)[0] : null; if (key !== null) { if (key === 'procedure_code') { if (val.procedure_code !== null && val.procedure_code !== undefined) { setActionLoader(true); try { const response = await fetch('https://app.nubrix.io/api/v1/workspace/formlookup', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ formData: allValues, changedValues: changedValues, slug: spaceSlug, workspaceId: workspaceId }) }); const data = await response.json(); let tot = data.total_charges; let tv = targetValue; tv = targetValue.map((item, index) => { if (index === len - 1) { return { ...item, total_charges: tot }; } else { return item; } }); setActionLoader(false); return tv; } catch (error) { setActionLoader(false); console.log('Error fetching data:', error); return targetValue; } } else if (val.procedure_code === null || val.procedure_code === undefined) { return targetValue; } else { return targetValue; } } else { return targetValue; } } else { return targetValue; } }\"}]},{\"type\":\"transformation\",\"dependentFields\":[{\"fieldType\":\"topOption\",\"fieldDataIndex\":\"subscriber_relationship\"}],\"targetFields\":[{\"fieldType\":\"topOption\",\"fieldDataIndex\":\"subscriber_first_name\",\"function\":\"function ( changedValues, reqdFieldValues, targetValue, allValues, schema, dataSource, moment, record) { if ( changedValues && changedValues.subscriber_relationship === 'self' ) { return record && record.first_name ? record.first_name : null; } if (changedValues && changedValues.subscriber_relationship !== 'self') { return ''; } return targetValue;}\"},{\"fieldType\":\"topOption\",\"fieldDataIndex\":\"subscriber_middle_name\",\"function\":\"function ( changedValues, reqdFieldValues, targetValue, allValues, schema, dataSource, moment, record) { if ( changedValues && changedValues.subscriber_relationship === 'self' ) { return record && record.middle_name ? record.middle_name : null; } if (changedValues && changedValues.subscriber_relationship !== 'self') { return ''; } return targetValue;}\"},{\"fieldType\":\"topOption\",\"fieldDataIndex\":\"subscriber_last_name\",\"function\":\"function ( changedValues, reqdFieldValues, targetValue, allValues, schema, dataSource, moment, record) { if ( changedValues && changedValues.subscriber_relationship === 'self' ) { return record && record.last_name ? record.last_name : null; } if (changedValues && changedValues.subscriber_relationship !== 'self') { return ''; } return targetValue;}\"},{\"fieldType\":\"topOption\",\"fieldDataIndex\":\"subscriber_dob\",\"function\":\"function ( changedValues, reqdFieldValues, targetValue, allValues, schema, dataSource, moment, record) { let formats = ['YYYY-MM-DDTHH:mm:ss.SSSZ', 'MM/DD/YYYY']; let dateVal = record && record.dob ? moment(record.dob, formats, true) : null; if (dateVal && dateVal.isValid()) { dateVal = dateVal.format('MM/DD/YYYY'); } else { dateVal = null; } if ( changedValues && changedValues.subscriber_relationship === 'self' ) { return dateVal ? moment(dateVal, 'MM/DD/YYYY') : dateVal; } if (changedValues && changedValues.subscriber_relationship !== 'self') { return null; } return targetValue;}\"},{\"fieldType\":\"topOption\",\"fieldDataIndex\":\"subscriber_sex\",\"function\":\"function ( changedValues, reqdFieldValues, targetValue, allValues, schema, dataSource, moment, record) { if ( changedValues && changedValues.subscriber_relationship === 'self' ) { return record && record.gender ? record.gender : null; } if (changedValues && changedValues.subscriber_relationship !== 'self') { return null; } return targetValue;}\"},{\"fieldType\":\"topOption\",\"fieldDataIndex\":\"street_address\",\"function\":\"function ( changedValues, reqdFieldValues, targetValue, allValues, schema, dataSource, moment, record) { if ( changedValues && changedValues.subscriber_relationship === 'self' ) { return record && record.street_address ? record.street_address : null; } if (changedValues && changedValues.subscriber_relationship !== 'self') { return null; } return targetValue;}\"},{\"fieldType\":\"topOption\",\"fieldDataIndex\":\"city\",\"function\":\"function ( changedValues, reqdFieldValues, targetValue, allValues, schema, dataSource, moment, record) { if ( changedValues && changedValues.subscriber_relationship === 'self' ) { return record && record.city ? record.city : null; } if (changedValues && changedValues.subscriber_relationship !== 'self') { return null; } return targetValue;}\"},{\"fieldType\":\"topOption\",\"fieldDataIndex\":\"state\",\"function\":\"function ( changedValues, reqdFieldValues, targetValue, allValues, schema, dataSource, moment, record) { if ( changedValues && changedValues.subscriber_relationship === 'self' ) { return record && record.state ? record.state : null; } if (changedValues && changedValues.subscriber_relationship !== 'self') { return null; } return targetValue;}\"},{\"fieldType\":\"topOption\",\"fieldDataIndex\":\"zip\",\"function\":\"function ( changedValues, reqdFieldValues, targetValue, allValues, schema, dataSource, moment, record) { if ( changedValues && changedValues.subscriber_relationship === 'self' ) { return record && record.zip ? record.zip : null; } if (changedValues && changedValues.subscriber_relationship !== 'self') { return null; } return targetValue;}\"}]},{\"type\":\"transformation\",\"dependentFields\":[{\"fieldType\":\"listOption\",\"fieldDataIndex\":\"listOptions\"}],\"targetFields\":[{\"fieldType\":\"listOption\",\"fieldDataIndex\":\"listOptions\",\"function\":\"function ( changedValues, reqdFieldValues, targetValue, allValues, schema) { let len = changedValues.listOptions.length; let val = changedValues.listOptions[len - 1]; let key = val ? Object.keys(val)[0] : null; if (key !== null) { if (key === 'quantity') {if ( targetValue[len - 1].unit_cost !== null && targetValue[len - 1].unit_cost !== undefined && val.quantity !== null && val.quantity !== undefined) { let tot = val.quantity * targetValue[len - 1].unit_cost; let tv = targetValue; tv = targetValue.map((item, index) => { if (index === len - 1) { return { ...item, total_cost: tot }; } else { return item; } }); return tv;} else if ( targetValue[len - 1].unit_cost !== null && targetValue[len - 1].unit_cost !== undefined && (val.quantity === null || val.quantity === undefined)) { let tv = targetValue; tv = targetValue.map((item, index) => { if (index === len - 1) { return { ...item, total_cost: null }; } else { return item; } }); return tv;} else { return targetValue;} } else if (key === 'unit_cost') {if ( val.unit_cost !== null && val.unit_cost !== undefined && targetValue[len - 1].quantity !== null && targetValue[len - 1].quantity !== undefined) { let tv = targetValue; tv = targetValue.map((item, index) => { if (index === len - 1) { return { ...item, total_cost: val.unit_cost * targetValue[len - 1].quantity }; } else { return item; } }); return tv;} else { let tv = targetValue; tv = targetValue.map((item, index) => { if (index === len - 1) { return { ...item, total_cost: null }; } else { return item; } }); return tv;} } } else { return targetValue; } }\"},{\"fieldType\":\"topOption\",\"fieldDataIndex\":\"total_price\",\"function\":\"function ( changedValues, reqdFieldValues, targetValue, allValues, schema) { let av = reqdFieldValues[0].listOptions; let tot = 0; av.forEach((item) => { if ( item !== null && item !== undefined && item.unit_cost !== null && item.unit_cost !== undefined && item.quantity !== null && item.quantity !== undefined ) { tot = tot + item.unit_cost * item.quantity; } }); return tot;}\"},{\"fieldType\":\"topOption\",\"fieldDataIndex\":\"total_quantity\",\"function\":\"function ( changedValues, reqdFieldValues, targetValue, allValues, schema) { let av = reqdFieldValues[0].listOptions; let tot = 0; av.forEach((item) => { if ( item !== null && item !== undefined && item.quantity !== null && item.quantity !== undefined ) { tot = tot + item.quantity; } }); return tot;}\"}]}]}\n<|endoftext|>"}
{"prompt": "provide me an advancedformnode schema which will contain only table where the columns are employee id (not editable, text), name (text, editable), age (number, editable), gender(select, options M,F,O, editable), Department(select, option_query, editable), role(text, editable), salary (number, editable)", "completion": "Schema:\n{\"defaultColumns\":[{\"key\":\"employee_id\",\"type\":\"text\",\"title\":\"Employee ID\",\"width\":100,\"dataIndex\":\"employee_id\",\"editable\":false},{\"key\":\"name\",\"type\":\"text\",\"title\":\"Name\",\"width\":150,\"dataIndex\":\"name\",\"editable\":true},{\"key\":\"age\",\"type\":\"number\",\"title\":\"Age\",\"width\":100,\"dataIndex\":\"age\",\"editable\":true},{\"key\":\"gender\",\"type\":\"select\",\"title\":\"Gender\",\"width\":100,\"dataIndex\":\"gender\",\"editable\":true,\"options\":[{\"value\":\"M\",\"display_value\":\"M\"},{\"value\":\"F\",\"display_value\":\"F\"},{\"value\":\"O\",\"display_value\":\"O\"}]},{\"key\":\"department\",\"type\":\"select\",\"title\":\"Department\",\"width\":200,\"dataIndex\":\"department\",\"editable\":true,\"options_query\":\"query|select id, name from departments\"},{\"key\":\"role\",\"type\":\"text\",\"title\":\"Role\",\"width\":150,\"dataIndex\":\"role\",\"editable\":true},{\"key\":\"salary\",\"type\":\"number\",\"title\":\"Salary\",\"width\":150,\"dataIndex\":\"salary\",\"editable\":true}],\"tableData\":[{\"key\":1,\"employee_id\":\"EMP001\",\"name\":\"John Doe\",\"age\":30,\"gender\":\"M\",\"department\":\"IT\",\"role\":\"Developer\",\"salary\":75000},{\"key\":2,\"employee_id\":\"EMP002\",\"name\":\"Alice Smith\",\"age\":28,\"gender\":\"F\",\"department\":\"HR\",\"role\":\"Manager\",\"salary\":85000},{\"key\":3,\"employee_id\":\"EMP003\",\"name\":\"David Johnson\",\"age\":35,\"gender\":\"O\",\"department\":\"Finance\",\"role\":\"Analyst\",\"salary\":90000}]}\n<|endoftext|>"}
{"prompt": "provide me advancedformnode schema which only contains antd form fields and the fields are: first name(text), last name(text), dob (date), gender(select, options: m,f,o), phone number(number), email(text), address(text), city(text), state(select, option: fetch usa state from query), country(text, default value: usa, read only), marital status(select, options: Single, Married, Divorced, Widowed), signature(signature type), profile picture(image_capture)", "completion": "Schema:\n{\"topOptions\":[{\"id\":\"1\",\"name\":\"first_name\",\"label\":\"First Name\",\"type\":\"text\",\"default_value\":null,\"is_read_only\":false,\"required\":true,\"size\":12,\"order\":1,\"onchange\":null},{\"id\":\"2\",\"name\":\"last_name\",\"label\":\"Last Name\",\"type\":\"text\",\"default_value\":null,\"is_read_only\":false,\"required\":true,\"size\":12,\"order\":2,\"onchange\":null},{\"id\":\"3\",\"name\":\"dob\",\"label\":\"Date of Birth\",\"type\":\"date\",\"default_value\":null,\"is_read_only\":false,\"required\":true,\"size\":12,\"order\":3,\"onchange\":null},{\"id\":\"4\",\"name\":\"gender\",\"label\":\"Gender\",\"type\":\"select\",\"default_value\":null,\"is_read_only\":false,\"required\":true,\"options\":[{\"value\":\"m\",\"display_value\":\"Male\"},{\"value\":\"f\",\"display_value\":\"Female\"},{\"value\":\"o\",\"display_value\":\"Other\"}],\"options_query\":null,\"size\":12,\"order\":4,\"onchange\":null},{\"id\":\"5\",\"name\":\"phone_number\",\"label\":\"Phone Number\",\"type\":\"number\",\"default_value\":null,\"is_read_only\":false,\"required\":true,\"size\":12,\"order\":5,\"onchange\":null},{\"id\":\"6\",\"name\":\"email\",\"label\":\"Email\",\"type\":\"text\",\"default_value\":null,\"is_read_only\":false,\"required\":true,\"size\":12,\"order\":6,\"onchange\":null},{\"id\":\"7\",\"name\":\"address\",\"label\":\"Address\",\"type\":\"text\",\"default_value\":null,\"is_read_only\":false,\"required\":true,\"size\":24,\"order\":7,\"onchange\":null},{\"id\":\"8\",\"name\":\"city\",\"label\":\"City\",\"type\":\"text\",\"default_value\":null,\"is_read_only\":false,\"required\":true,\"size\":12,\"order\":8,\"onchange\":null},{\"id\":\"9\",\"name\":\"state\",\"label\":\"State\",\"type\":\"select\",\"default_value\":null,\"is_read_only\":false,\"required\":true,\"options\":null,\"options_query\":\"query|SELECT name, name FROM usa_states\",\"size\":12,\"order\":9,\"onchange\":null},{\"id\":\"10\",\"name\":\"country\",\"label\":\"Country\",\"type\":\"text\",\"default_value\":\"USA\",\"is_read_only\":true,\"required\":true,\"size\":12,\"order\":10,\"onchange\":null},{\"id\":\"11\",\"name\":\"marital_status\",\"label\":\"Marital Status\",\"type\":\"select\",\"default_value\":null,\"is_read_only\":false,\"required\":true,\"options\":[{\"value\":\"single\",\"display_value\":\"Single\"},{\"value\":\"married\",\"display_value\":\"Married\"},{\"value\":\"divorced\",\"display_value\":\"Divorced\"},{\"value\":\"widowed\",\"display_value\":\"Widowed\"}],\"options_query\":null,\"size\":12,\"order\":11,\"onchange\":null},{\"id\":\"12\",\"name\":\"signature\",\"label\":\"Signature\",\"type\":\"signature\",\"default_value\":null,\"is_read_only\":false,\"required\":true,\"size\":12,\"order\":12,\"onchange\":null},{\"id\":\"13\",\"name\":\"profile_picture\",\"label\":\"Profile Picture\",\"type\":\"image_capture\",\"default_value\":null,\"is_read_only\":false,\"required\":true,\"size\":12,\"order\":13,\"onchange\":null}]}\n<|endoftext|>"}
{"prompt": "now provide me an advancedformnode schema which contains an antd form and table. The fields for the antd form is: first name(text), last name(text), dob (date), gender(select, options: m,f,o), phone number(number), email(text), address(text), city(text), state(select, option: fetch usa state from query), country(text, default value: usa, read only), marital status(select, options: Single, Married, Divorced, Widowed), signature(signature type), profile picture(image_capture) the data for the table is as: employee id (not editable, text), name (text, editable), age (number, editable), gender(select, options M,F,O, editable), Department(select, option_query, editable), role(text, editable), salary (number, editable).", "completion": "Schema:\n{\"topOptions\":[{\"id\":\"1\",\"name\":\"first_name\",\"label\":\"First Name\",\"type\":\"text\",\"default_value\":null,\"is_read_only\":false,\"required\":true,\"size\":12,\"order\":1,\"onchange\":null},{\"id\":\"2\",\"name\":\"last_name\",\"label\":\"Last Name\",\"type\":\"text\",\"default_value\":null,\"is_read_only\":false,\"required\":true,\"size\":12,\"order\":2,\"onchange\":null},{\"id\":\"3\",\"name\":\"dob\",\"label\":\"Date of Birth\",\"type\":\"date\",\"default_value\":null,\"is_read_only\":false,\"required\":true,\"size\":12,\"order\":3,\"onchange\":null},{\"id\":\"4\",\"name\":\"gender\",\"label\":\"Gender\",\"type\":\"select\",\"default_value\":null,\"is_read_only\":false,\"required\":true,\"options\":[{\"value\":\"m\",\"display_value\":\"Male\"},{\"value\":\"f\",\"display_value\":\"Female\"},{\"value\":\"o\",\"display_value\":\"Other\"}],\"options_query\":null,\"size\":12,\"order\":4,\"onchange\":null},{\"id\":\"5\",\"name\":\"phone_number\",\"label\":\"Phone Number\",\"type\":\"number\",\"default_value\":null,\"is_read_only\":false,\"required\":true,\"size\":12,\"order\":5,\"onchange\":null},{\"id\":\"6\",\"name\":\"email\",\"label\":\"Email\",\"type\":\"text\",\"default_value\":null,\"is_read_only\":false,\"required\":true,\"size\":12,\"order\":6,\"onchange\":null},{\"id\":\"7\",\"name\":\"address\",\"label\":\"Address\",\"type\":\"text\",\"default_value\":null,\"is_read_only\":false,\"required\":true,\"size\":24,\"order\":7,\"onchange\":null},{\"id\":\"8\",\"name\":\"city\",\"label\":\"City\",\"type\":\"text\",\"default_value\":null,\"is_read_only\":false,\"required\":true,\"size\":12,\"order\":8,\"onchange\":null},{\"id\":\"9\",\"name\":\"state\",\"label\":\"State\",\"type\":\"select\",\"default_value\":null,\"is_read_only\":false,\"required\":true,\"options\":null,\"options_query\":\"query|SELECT name, name FROM usa_states\",\"size\":12,\"order\":9,\"onchange\":null},{\"id\":\"10\",\"name\":\"country\",\"label\":\"Country\",\"type\":\"text\",\"default_value\":\"USA\",\"is_read_only\":true,\"required\":true,\"size\":12,\"order\":10,\"onchange\":null},{\"id\":\"11\",\"name\":\"marital_status\",\"label\":\"Marital Status\",\"type\":\"select\",\"default_value\":null,\"is_read_only\":false,\"required\":true,\"options\":[{\"value\":\"single\",\"display_value\":\"Single\"},{\"value\":\"married\",\"display_value\":\"Married\"},{\"value\":\"divorced\",\"display_value\":\"Divorced\"},{\"value\":\"widowed\",\"display_value\":\"Widowed\"}],\"options_query\":null,\"size\":12,\"order\":11,\"onchange\":null},{\"id\":\"12\",\"name\":\"signature\",\"label\":\"Signature\",\"type\":\"signature\",\"default_value\":null,\"is_read_only\":false,\"required\":true,\"size\":12,\"order\":12,\"onchange\":null},{\"id\":\"13\",\"name\":\"profile_picture\",\"label\":\"Profile Picture\",\"type\":\"image_capture\",\"default_value\":null,\"is_read_only\":false,\"required\":true,\"size\":12,\"order\":13,\"onchange\":null}],\"defaultColumns\":[{\"title\":\"Employee ID\",\"dataIndex\":\"employee_id\",\"key\":\"employee_id\",\"editable\":false,\"type\":\"text\"},{\"title\":\"Name\",\"dataIndex\":\"name\",\"key\":\"name\",\"editable\":true,\"type\":\"text\"},{\"title\":\"Age\",\"dataIndex\":\"age\",\"key\":\"age\",\"editable\":true,\"type\":\"number\"},{\"title\":\"Gender\",\"dataIndex\":\"gender\",\"key\":\"gender\",\"editable\":true,\"type\":\"select\",\"options\":[{\"value\":\"m\",\"display_value\":\"Male\"},{\"value\":\"f\",\"display_value\":\"Female\"},{\"value\":\"o\",\"display_value\":\"Other\"}]},{\"title\":\"Department\",\"dataIndex\":\"department\",\"key\":\"department\",\"editable\":true,\"type\":\"select\",\"options_query\":\"query|SELECT id, name FROM departments\"},{\"title\":\"Role\",\"dataIndex\":\"role\",\"key\":\"role\",\"editable\":true,\"type\":\"text\"},{\"title\":\"Salary\",\"dataIndex\":\"salary\",\"key\":\"salary\",\"editable\":true,\"type\":\"number\"}],\"tableData\":[{\"employee_id\":\"E001\",\"name\":\"John Doe\",\"age\":30,\"gender\":\"m\",\"department\":\"IT\",\"role\":\"Developer\",\"salary\":60000},{\"employee_id\":\"E002\",\"name\":\"Jane Smith\",\"age\":25,\"gender\":\"f\",\"department\":\"HR\",\"role\":\"Manager\",\"salary\":50000}]}\n<|endoftext|>"}
{"prompt": "provide me schema for the advancedformnode which only contains antd form list with the fields being: task name(text, required), description(text, not required), priority(select, use options key and generate options on your own), due date(date, required), estimated time(number), status (select, fetch options in options_query), working hours(timerange), item number new(display none, text), unique id (random8digitbarcode, is read only)", "completion": "Schema:\n{\"listOptions\":[{\"default_value\":null,\"id\":\"1\",\"is_read_only\":false,\"label\":\"Task Name\",\"name\":\"task_name\",\"onchange\":null,\"options\":null,\"options_query\":null,\"order\":1,\"size\":3,\"type\":\"text\",\"required\":true},{\"default_value\":null,\"id\":\"2\",\"is_read_only\":false,\"label\":\"Description\",\"name\":\"description\",\"onchange\":null,\"options\":null,\"options_query\":null,\"order\":2,\"size\":6,\"type\":\"text\",\"required\":false},{\"default_value\":null,\"id\":\"3\",\"is_read_only\":false,\"label\":\"Priority\",\"name\":\"priority\",\"onchange\":null,\"options\":[{\"display_value\":\"Low\",\"value\":\"low\"},{\"display_value\":\"Medium\",\"value\":\"medium\"},{\"display_value\":\"High\",\"value\":\"high\"}],\"options_query\":null,\"order\":3,\"size\":3,\"type\":\"select\",\"required\":true},{\"default_value\":null,\"id\":\"4\",\"is_read_only\":false,\"label\":\"Due Date\",\"name\":\"due_date\",\"onchange\":null,\"options\":null,\"options_query\":null,\"order\":4,\"size\":3,\"type\":\"date\",\"required\":true},{\"default_value\":null,\"id\":\"5\",\"is_read_only\":false,\"label\":\"Estimated Time (hours)\",\"name\":\"estimated_time\",\"onchange\":null,\"options\":null,\"options_query\":null,\"order\":5,\"size\":3,\"type\":\"number\",\"required\":false},{\"default_value\":null,\"id\":\"6\",\"is_read_only\":false,\"label\":\"Status\",\"name\":\"status\",\"onchange\":null,\"options\":null,\"options_query\":\"query|select id, status_name from task_statuses\",\"order\":6,\"size\":3,\"type\":\"select\",\"required\":true},{\"default_value\":null,\"id\":\"7\",\"is_read_only\":false,\"label\":\"Working Hours\",\"name\":\"working_hours\",\"onchange\":null,\"options\":null,\"options_query\":null,\"order\":7,\"size\":3,\"type\":\"timerange\",\"required\":true},{\"default_value\":null,\"id\":\"8\",\"is_read_only\":true,\"label\":\"Item Number New\",\"name\":\"item_number_new\",\"onchange\":null,\"options\":null,\"options_query\":null,\"order\":8,\"size\":3,\"type\":\"text\",\"display\":\"none\",\"rows\":[]},{\"default_value\":null,\"id\":\"9\",\"is_read_only\":true,\"label\":\"Unique ID\",\"name\":\"unique_id\",\"onchange\":null,\"options\":null,\"options_query\":null,\"order\":9,\"size\":3,\"type\":\"random8digitbarcode\",\"required\":true,\"display\":\"\",\"rows\":[]}]}\n<|endoftext|>"}
{"prompt": "give me dependencies for the following cases based on your training from the schema: the tablecolumn employee_id should start with 8302 and should be of 8 digits. the tablecolumn remaining_amount should be greater than 0. the listOption net_income should be equal to liquid_income + net_assets - net_liabilities. the topOption birthdate can’t be less than the year 2004.", "completion": "Schema:\n{\"dependencies\":[{\"type\":\"validation\",\"checkType\":\"hard\",\"targetFields\":[{\"fieldType\":\"tableColumn\",\"fieldName\":\"employee_id\",\"message\":\"Employee ID must start with 8302 and be exactly 8 digits.\",\"function\":\"function (value) { return !(value && value.startsWith('8302') && value.length === 8 && !isNaN(Number(value))); }\"}]},{\"type\":\"validation\",\"checkType\":\"hard\",\"targetFields\":[{\"fieldType\":\"tableColumn\",\"fieldName\":\"remaining_amount\",\"ruleSchema\":{\"type\":\"number\",\"min\":0.01,\"message\":\"Remaining Amount must be greater than 0.\"}}]},{\"type\":\"validation\",\"checkType\":\"hard\",\"dependentFields\":[{\"fieldType\":\"listOption\"}],\"targetFields\":[{\"fieldType\":\"listOption\",\"fieldName\":\"net_income\",\"message\":\"Net Income must equal Liquid Income + Net Assets - Net Liabilities.\",\"function\":\"function (value, currentItem) { let netIncome = value ? value : 0; let liquidIncome = currentItem.liquid_income ? currentItem.liquid_income : 0; let netAssets = currentItem.net_assets ? currentItem.net_assets : 0; let netLiabilities = currentItem.net_liabilities ? currentItem.net_liabilities : 0; return (netIncome !== (liquidIncome + netAssets - netLiabilities)); }\"}]},{\"type\":\"validation\",\"checkType\":\"hard\",\"dependentFields\":[{\"fieldType\":\"topOption\",\"fieldDataIndex\":\"birthdate\"}],\"targetFields\":[{\"fieldType\":\"topOption\",\"fieldName\":\"birthdate\",\"message\":\"Birthdate cannot be earlier than the year 2004.\",\"function\":\"function (value) { if (!value) { return true; } let birthYear = new Date(value).getFullYear(); return birthYear < 2004; }\"}]}]}\n<|endoftext|>"}
{"prompt": "provide me dependencies for the following cases if the default value of the gender field in topoptions is M then set the income_field display to '' and occupation fields display to 'none'. another case is loop over the table data and set the summation of expenses as the default value for the total_expenses topoption field. last one is take this image metadata data:image/png;base64,iVBORw0KGgoAAleifjhksjefeajkfnjkajf and set it as newsigns and set the signatureRefs['signature'].current ", "completion": "Schema:\n{\"dependencies\":[{\"type\":\"onLoadDependency\",\"targetFields\":[{\"fieldType\":\"topOption\",\"fieldDataIndex\":\"gender\",\"function\":\"function (topOptions, signData, tabData) { let newTop = topOptions; let genderField = newTop.find(item => item.name === 'gender'); if (genderField.default_value === 'M') { newTop = newTop.map(item => { if (item.name === 'income_field') { return { ...item, display: '' }; } else if (item.name === 'occupation') { return { ...item, display: 'none' }; } else { return item; }}); } return newTop; }\"}]},{\"type\":\"onLoadDependency\",\"targetFields\":[{\"fieldType\":\"topOption\",\"fieldDataIndex\":\"total_expenses\",\"function\":\"function (topOptions, signData, tabData) { let newTop = topOptions; let totalExpenses = 0; tabData.forEach(row => { if (!isNaN(row.expenses) && row.expenses !== undefined && row.expenses !== null) { totalExpenses += row.expenses; }}); newTop = newTop.map(item => { if (item.name === 'total_expenses') { return { ...item, default_value: totalExpenses }; } else { return item; }}); return newTop; }\"}]},{\"type\":\"onLoadDependency\",\"targetFields\":[{\"fieldType\":\"topOption\",\"fieldDataIndex\":\"signature\",\"function\":\"function (topOptions, signData, tabData) { let newTop = topOptions; let newsigns = signData; newsigns = { ...newsigns, signature: 'data:image/png;base64,iVBORw0KGgoAAleifjhksjefeajkfnjkajf' }; signatureRefs['signature'].current = 'data:image/png;base64,iVBORw0KGgoAAleifjhksjefeajkfnjkajf'; return { newTop, newsigns }; }\"}]}]}\n<|endoftext|>"}